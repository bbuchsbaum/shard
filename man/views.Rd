% Generated by hand for shard views (no roxygen run required)
\name{views}
\alias{idx_range}
\alias{view}
\alias{view_block}
\alias{view_info}
\alias{is_view}
\alias{is_block_view}
\alias{view_diagnostics}
\title{Zero-copy views for shared matrices}
\usage{
idx_range(start, end)

view(x, rows = NULL, cols = NULL, type = c("auto", "block", "gather"))

view_block(x, rows = NULL, cols = NULL)

view_info(v)

is_view(x)

is_block_view(x)

view_diagnostics()
}
\arguments{
\item{start}{Integer. Start index (1-based, inclusive).}
\item{end}{Integer. End index (1-based, inclusive).}
\item{x}{A shared (share()d) atomic matrix (double/integer/logical/raw).}
\item{rows}{Row selector. NULL (all rows) or \code{idx_range()}.}
\item{cols}{Column selector. NULL (all cols) or \code{idx_range()}.}
\item{type}{View type. Currently only \code{"block"} is implemented.}
\item{v}{A shard view object.}
}
\value{
\itemize{
  \item \code{idx_range()}: an object of class \code{shard_idx_range}.
  \item \code{view()}, \code{view_block()}: an object of class \code{shard_view_block}.
  \item \code{view_info()}: a named list describing the view.
  \item \code{is_view()}, \code{is_block_view()}: logical.
  \item \code{view_diagnostics()}: a list of global counters.
}
}
\description{
Views are explicit slice descriptors over shared matrices. They avoid creating
slice-sized allocations (e.g., \code{Y[, a:b]}) by carrying only metadata plus a
reference to the shared backing. Use \code{materialize()} to explicitly copy a
view into a standard matrix.
}
\details{
Views are an optimization handle for shard-aware kernels and workflows. Base R
operations are not guaranteed to operate on a view without materializing data.

Gather/indexed views are planned but not yet implemented.
}
\examples{
\dontrun{
Y <- matrix(rnorm(1000), nrow = 100)
Ysh <- share(Y, backing = "mmap")

v <- view_block(Ysh, cols = idx_range(11, 20))
info <- view_info(v)
print(info$layout)

Ychunk <- materialize(v)
stopifnot(all.equal(Ychunk, Y[, 11:20, drop = FALSE]))
}
}

